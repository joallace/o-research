#include "include/bb.h"

BB::BB(double ***matrix_pointer, int dimension): Problem(matrix_pointer, dimension){
    // Heuristic used to get an initial upper bound
    TSP heuristic = TSP(matrix_pointer, dimension, 1);

    // The chosen subtour index
    int index;

    for(int i = 0; i < dimension_; i++)
        matrix_[i][i] = HUNGARIAN_INFINITY;

    // Inserting the root node
    tree_.push_front({{}, HUNGARIAN_INFINITY});

    // s_ = heuristic.getSolution();
    // upper_bound = heuristic.getCost();
    upper_bound = HUNGARIAN_INFINITY;
    s_.cost = HUNGARIAN_INFINITY;

    // Executing until there is no nodes left to process
    while(!tree_.empty()){        
        hungarian_init(&p_, matrix_, dimension_, dimension_, HUNGARIAN_MODE_MINIMIZE_COST);

        current_node = tree_.begin();
            
        vector_solve();

        if(current_node->cost > upper_bound){
            tree_.erase(current_node);
			continue;
        }

		if(subtours_.size() == 1){
			if(current_node->cost < s_.cost){
				s_ = {subtours_[0], current_node->cost};
				upper_bound = current_node->cost;
                std::cout << "New minimum: " << s_.cost << "\n";
			}

			tree_.erase(current_node);
			continue;
		}

        // std::cout << "Current node cost: " << current_node->cost << "\n";
        // for(int i = 0; i < subtours_.size()-1; i++){
        //     std::cout << "Subtour " << i+1 << ": ";
        //     printRoute(subtours_[i]);
        // }
        // std::cout << "\n";

        index = getSubtourIndex();

        for(int i = 0; i < subtours_[index].size()-1; i++){
            tNode child;
            
            child.forbidden = current_node->forbidden;
            child.forbidden.push_back({subtours_[index][i], subtours_[index][i+1]});
            tree_.push_front(child);
        }

        // After we generated the children, we can delete the node
        tree_.erase(current_node);

        hungarian_free(&p_);
    }
}

// A function that solves and converts the resulting assignment matrix generated by the hungarian algorithm to a vector of subtours_
void BB::vector_solve(){
    std::vector<int> subtour = {0};
    bool used_nodes[dimension_] = {};
    bool finished;

    subtours_.clear();

    // Prohibiting the set of arcs of the current node
    for(int i = 0; i < current_node->forbidden.size(); i++)
        p_.cost[current_node->forbidden[i].first][current_node->forbidden[i].second] = HUNGARIAN_INFINITY;

    current_node->cost = hungarian_solve(&p_);
    used_nodes[0] = true;

    // Matrix to vector conversion
    do{
        do{
            for(int i = 0; i < dimension_; i++){
                if(p_.assignment[subtour[subtour.size()-1]][i]){
                    subtour.push_back(i);
                    used_nodes[i] = true;
                    break;
                }
            }
        }while((subtour[0] != subtour[subtour.size()-1]));
        
        subtours_.push_back(subtour);
        subtour.clear();

        finished = true;
        for(int i = 1; i < dimension_; i++)
            if(!used_nodes[i]){
                subtour.push_back(i);
                used_nodes[i] = true;
                finished = false;
                break;
            }
    }while(!finished);
}

// Chooses the first subtour with the smallest size
int BB::getSubtourIndex(){
    int index = 0;

    for(int i = 1, smallest_size = subtours_[0].size(); i < subtours_.size(); i++)
        if(subtours_[i].size() < smallest_size){
            smallest_size = subtours_[i].size();
            index = i;
        }
    
    return index;
}

void BB::printSolution(){
    printRoute(s_.route);
}

void BB::printTimes(){
    std::cout << "AAA\n";
}

double BB::getCost(){
    return s_.cost;
}

void BB::printAssingmentMatrix(){
    std::cout << "Dimension: " << dimension_ << "\n\n";
    for(int i = 0; i < dimension_; i++){
        for(int j = 0; j < dimension_; j++){
            char endian = ((j+1)==dimension_) ? '\n' : ' ';
            std::cout << p_.assignment[i][j] << endian;
        }
    }
}